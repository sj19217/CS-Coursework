start "int count = 0;\nint pow = 1;\n\nvoid main()\n{\n    while (count < 5) {\n        count = count + 1;\n        pow = pow * 2;\n        printf(pow);\n    }\n}"
prep_ifanalysis "[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]"
prep_if "int count = 0;\nint pow = 1;\n\nvoid main()\n{\n    while (count < 5) {\n        count = count + 1;\n        pow = pow * 2;\n        printf(pow);\n    }\n}"
prep_done "int count = 0;\nint pow = 1;\nvoid main()\n{\n    while (count < 5) {\n        count = count + 1;\n        pow = pow * 2;\n        printf(pow);\n    }\n}"
tree {"_nodetype": "FileAST", "ext": [{"_nodetype": "Decl", "name": "count", "quals": [], "storage": [], "funcspec": [], "coord": ":1:5", "type": {"_nodetype": "TypeDecl", "declname": "count", "quals": [], "coord": ":1:5", "type": {"_nodetype": "IdentifierType", "names": ["int"], "coord": ":1:1"}}, "init": {"_nodetype": "Constant", "type": "int", "value": "0", "coord": ":1:13"}, "bitsize": null}, {"_nodetype": "Decl", "name": "pow", "quals": [], "storage": [], "funcspec": [], "coord": ":2:5", "type": {"_nodetype": "TypeDecl", "declname": "pow", "quals": [], "coord": ":2:5", "type": {"_nodetype": "IdentifierType", "names": ["int"], "coord": ":2:1"}}, "init": {"_nodetype": "Constant", "type": "int", "value": "1", "coord": ":2:11"}, "bitsize": null}, {"_nodetype": "FuncDef", "coord": ":3:6", "decl": {"_nodetype": "Decl", "name": "main", "quals": [], "storage": [], "funcspec": [], "coord": ":3:6", "type": {"_nodetype": "FuncDecl", "coord": ":3:6", "type": {"_nodetype": "TypeDecl", "declname": "main", "quals": [], "coord": ":3:6", "type": {"_nodetype": "IdentifierType", "names": ["void"], "coord": ":3:1"}}, "args": null}, "bitsize": null, "init": null}, "body": {"_nodetype": "Compound", "coord": ":4:1", "block_items": [{"_nodetype": "While", "coord": ":5:5", "cond": {"_nodetype": "BinaryOp", "op": "<", "coord": ":5:12", "left": {"_nodetype": "ID", "name": "count", "coord": ":5:12"}, "right": {"_nodetype": "Constant", "type": "int", "value": "5", "coord": ":5:20"}}, "stmt": {"_nodetype": "Compound", "coord": ":5:1", "block_items": [{"_nodetype": "Assignment", "op": "=", "coord": ":6:9", "lvalue": {"_nodetype": "ID", "name": "count", "coord": ":6:9"}, "rvalue": {"_nodetype": "BinaryOp", "op": "+", "coord": ":6:17", "left": {"_nodetype": "ID", "name": "count", "coord": ":6:17"}, "right": {"_nodetype": "Constant", "type": "int", "value": "1", "coord": ":6:25"}}}, {"_nodetype": "Assignment", "op": "=", "coord": ":7:9", "lvalue": {"_nodetype": "ID", "name": "pow", "coord": ":7:9"}, "rvalue": {"_nodetype": "BinaryOp", "op": "*", "coord": ":7:15", "left": {"_nodetype": "ID", "name": "pow", "coord": ":7:15"}, "right": {"_nodetype": "Constant", "type": "int", "value": "2", "coord": ":7:21"}}}, {"_nodetype": "FuncCall", "coord": ":8:9", "name": {"_nodetype": "ID", "name": "printf", "coord": ":8:9"}, "args": {"_nodetype": "ExprList", "coord": ":8:16", "exprs": [{"_nodetype": "ID", "name": "pow", "coord": ":8:16"}]}}], "locals": null, "parent": null}}], "locals": null, "parent": null}, "param_decls": null}]}
found_global ["count", "int", "0"]
found_global ["pow", "int", "1"]
locals
start_codegen
gen_data
gen_data_line ["count", "int", "0"]
gen_data_line ["pow", "int", "1"]
fin_gen_data "count VAR int 0\npow VAR int 1\n"
gen_text
gen_block block
gen_stmt ["Generating code to evaluate a binary comparison (<)", "; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Making comparison (<)\nCMP uint ecx edx\nJLT jmptrue_87b1ba63\nJMP jmpfalse_87b1ba63\njmptrue_87b1ba63 SUB esp 4\nMOV 4B [esp] 1\nJMP jmpcmpend_87b1ba63\njmpfalse_87b1ba63 SUB esp 4\nMOV 4B [esp] 0\njmpcmpend_87b1ba63 MOV 4B eax eax    ; Determined truth and added to stack\n"]
gen_stmt ["Generated code for while loop", "; Beginning while loop\nwhile_{rand} ; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 5\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Making comparison (<)\nCMP uint ecx edx\nJLT jmptrue_87b1ba63\nJMP jmpfalse_87b1ba63\njmptrue_87b1ba63 SUB esp 4\nMOV 4B [esp] 1\nJMP jmpcmpend_87b1ba63\njmpfalse_87b1ba63 SUB esp 4\nMOV 4B [esp] 0\njmpcmpend_87b1ba63 MOV 4B eax eax    ; Determined truth and added to stack\nCMP int [esp] 1  ; See if true and jump accordingly\nADD uint esp 4\nJNE endwhile_{rand}\n; Running child block\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 1\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing + and pushing to stack\nADD int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable count\nLEA edi count      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 2\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing * and pushing to stack\nMUL int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable pow\nLEA edi pow      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Calling printf\nMOV 4B out [esp]\nADD uint esp 4\nJMP while_{rand}\nendwhile_{rand} MOV 4B eax eax\n"]
finish "section.meta\nmem_amt=4\n\nsection.data\ncount VAR int 0\npow VAR int 1\n\n\nsection.text\nMOV 4B esp 2048\nMOV 4B ebp 2048\n; Beginning while loop\nwhile_08a3d39e ; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 5\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Making comparison (<)\nCMP uint ecx edx\nJLT jmptrue_87b1ba63\nJMP jmpfalse_87b1ba63\njmptrue_87b1ba63 SUB esp 4\nMOV 4B [esp] 1\nJMP jmpcmpend_87b1ba63\njmpfalse_87b1ba63 SUB esp 4\nMOV 4B [esp] 0\njmpcmpend_87b1ba63 MOV 4B eax eax    ; Determined truth and added to stack\nCMP int [esp] 1  ; See if true and jump accordingly\nADD uint esp 4\nJNE endwhile_08a3d39e\n; Running child block\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 1\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing + and pushing to stack\nADD int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable count\nLEA edi count      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 2\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing * and pushing to stack\nMUL int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable pow\nLEA edi pow      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Calling printf\nMOV 4B out [esp]\nADD uint esp 4\nJMP while_08a3d39e\nendwhile_08a3d39e MOV 4B eax eax\nexit HLT\n\n"
