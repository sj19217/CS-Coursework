start "int count = 0;\nint pow = 1;\n\nvoid main()\n{\n    while (count < 5) {\n        count = count + 1;\n        pow = pow * 2;\n        printf(pow);\n    }\n}"
prep_ifanalysis "[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]\n[]"
prep_if "int count = 0;\nint pow = 1;\n\nvoid main()\n{\n    while (count < 5) {\n        count = count + 1;\n        pow = pow * 2;\n        printf(pow);\n    }\n}"
prep_done "int count = 0;\nint pow = 1;\nvoid main()\n{\n    while (count < 5) {\n        count = count + 1;\n        pow = pow * 2;\n        printf(pow);\n    }\n}"
tree {"_nodetype": "FileAST", "ext": [{"_nodetype": "Decl", "quals": [], "bitsize": null, "init": {"type": "int", "_nodetype": "Constant", "value": "0", "coord": ":1:13"}, "name": "count", "type": {"type": {"_nodetype": "IdentifierType", "names": ["int"], "coord": ":1:1"}, "_nodetype": "TypeDecl", "quals": [], "declname": "count", "coord": ":1:5"}, "storage": [], "funcspec": [], "coord": ":1:5"}, {"_nodetype": "Decl", "quals": [], "bitsize": null, "init": {"type": "int", "_nodetype": "Constant", "value": "1", "coord": ":2:11"}, "name": "pow", "type": {"type": {"_nodetype": "IdentifierType", "names": ["int"], "coord": ":2:1"}, "_nodetype": "TypeDecl", "quals": [], "declname": "pow", "coord": ":2:5"}, "storage": [], "funcspec": [], "coord": ":2:5"}, {"decl": {"_nodetype": "Decl", "quals": [], "bitsize": null, "init": null, "name": "main", "type": {"type": {"type": {"_nodetype": "IdentifierType", "names": ["void"], "coord": ":3:1"}, "_nodetype": "TypeDecl", "quals": [], "declname": "main", "coord": ":3:6"}, "_nodetype": "FuncDecl", "args": null, "coord": ":3:6"}, "storage": [], "funcspec": [], "coord": ":3:6"}, "_nodetype": "FuncDef", "body": {"block_items": [{"_nodetype": "While", "stmt": {"block_items": [{"op": "=", "_nodetype": "Assignment", "lvalue": {"_nodetype": "ID", "coord": ":6:9", "name": "count"}, "rvalue": {"op": "+", "_nodetype": "BinaryOp", "right": {"type": "int", "_nodetype": "Constant", "value": "1", "coord": ":6:25"}, "left": {"_nodetype": "ID", "coord": ":6:17", "name": "count"}, "coord": ":6:17"}, "coord": ":6:9"}, {"op": "=", "_nodetype": "Assignment", "lvalue": {"_nodetype": "ID", "coord": ":7:9", "name": "pow"}, "rvalue": {"op": "*", "_nodetype": "BinaryOp", "right": {"type": "int", "_nodetype": "Constant", "value": "2", "coord": ":7:21"}, "left": {"_nodetype": "ID", "coord": ":7:15", "name": "pow"}, "coord": ":7:15"}, "coord": ":7:9"}, {"_nodetype": "FuncCall", "name": {"_nodetype": "ID", "coord": ":8:9", "name": "printf"}, "args": {"_nodetype": "ExprList", "exprs": [{"_nodetype": "ID", "coord": ":8:16", "name": "pow"}], "coord": ":8:16"}, "coord": ":8:9"}], "_nodetype": "Compound", "parent": null, "locals": null, "coord": ":5:1"}, "cond": {"op": "<", "_nodetype": "BinaryOp", "right": {"type": "int", "_nodetype": "Constant", "value": "5", "coord": ":5:20"}, "left": {"_nodetype": "ID", "coord": ":5:12", "name": "count"}, "coord": ":5:12"}, "coord": ":5:5"}], "_nodetype": "Compound", "parent": null, "locals": null, "coord": ":4:1"}, "param_decls": null, "coord": ":3:6"}]}
found_global ["count", "int", "0"]
found_global ["pow", "int", "1"]
locals
start_codegen
gen_data
gen_data_line ["pow", "int", "1"]
gen_data_line ["count", "int", "0"]
fin_gen_data "pow VAR int 1\ncount VAR int 0\n"
gen_text
gen_block block
gen_stmt ["Generating code to evaluate a binary comparison (<)", "; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Making comparison (<)\nCMP uint ecx edx\nJLT jmptrue_5276762a\nJMP jmpfalse_5276762a\njmptrue_5276762a SUB esp 4\nMOV 4B [esp] 1\nJMP jmpcmpend_5276762a\njmpfalse_5276762a SUB esp 4\nMOV 4B [esp] 0\njmpcmpend_5276762a MOV 4B eax eax    ; Determined truth and added to stack\n"]
gen_stmt ["Generated code for while loop", "; Beginning while loop\nwhile_{rand} ; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 5\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Making comparison (<)\nCMP uint ecx edx\nJLT jmptrue_5276762a\nJMP jmpfalse_5276762a\njmptrue_5276762a SUB esp 4\nMOV 4B [esp] 1\nJMP jmpcmpend_5276762a\njmpfalse_5276762a SUB esp 4\nMOV 4B [esp] 0\njmpcmpend_5276762a MOV 4B eax eax    ; Determined truth and added to stack\nCMP int [esp] 1  ; See if true and jump accordingly\nADD uint esp 4\nJNE endwhile_{rand}\n; Running child block\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 1\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing + and pushing to stack\nADD int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable count\nLEA edi count      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 2\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing * and pushing to stack\nMUL int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable pow\nLEA edi pow      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Calling printf\nMOV 4B out [esp]\nADD uint esp 4\nJMP while_{rand}\nendwhile_{rand} MOV 4B eax eax\n"]
finish "section.meta\nmem_amt=4\n\nsection.data\npow VAR int 1\ncount VAR int 0\n\n\nsection.text\nMOV 4B esp 2048\nMOV 4B ebp 2048\n; Beginning while loop\nwhile_d8c1efc2 ; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 5\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Making comparison (<)\nCMP uint ecx edx\nJLT jmptrue_5276762a\nJMP jmpfalse_5276762a\njmptrue_5276762a SUB esp 4\nMOV 4B [esp] 1\nJMP jmpcmpend_5276762a\njmpfalse_5276762a SUB esp 4\nMOV 4B [esp] 0\njmpcmpend_5276762a MOV 4B eax eax    ; Determined truth and added to stack\nCMP int [esp] 1  ; See if true and jump accordingly\nADD uint esp 4\nJNE endwhile_d8c1efc2\n; Running child block\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] count\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 1\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing + and pushing to stack\nADD int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable count\nLEA edi count      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Pushing constant to stack\nSUB uint esp 4\nMOV 4B [esp] 2\n; Evaluating binary expression: Popping values to registers.\nMOV 4B edx [esp]\nADD uint esp 4\nMOV 4B ecx [esp]\nADD uint esp 4\n; Performing * and pushing to stack\nMUL int ecx edx\nSUB uint esp 4\nMOV 4B [esp] ecx\n; Assigning top of stack to variable pow\nLEA edi pow      ; Pointer to a global\n; Move from stack to variable\nMOV 4B ecx [esp]\nADD uint esp 4\nMOV 4B [edi] ecx\n; Pushing global variable to stack\nSUB uint esp 4\nMOV 4B [esp] pow\n; Calling printf\nMOV 4B out [esp]\nADD uint esp 4\nJMP while_d8c1efc2\nendwhile_d8c1efc2 MOV 4B eax eax\nexit HLT\n\n"
